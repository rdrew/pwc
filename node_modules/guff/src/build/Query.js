import {client} from '../utils'


const upperRepl = /([A-Z]+)/g
export function toUpper (k, v) {
  if (v === false) {
    return null
  }

  return k.replace(upperRepl, ' $1').toUpperCase()
}

export function safe (v) {
  return v
}

export function identifier (k, v) {
  if (v !== void 0 && v !== null) {
    const bindingKey = `${k}Binding`
    return [`:${bindingKey}:`, {[bindingKey]: v}]
  }
}

export function identifierBindings (k, v) {
  if (v !== void 0 && v !== null) {
    const bindingKey = `${k}Binding`
    return [`${toUpper(k)} :${bindingKey}:`, {[bindingKey]: v}]
  }
}

export function conditionalBindings (k, v) {
  if (v !== void 0 && v !== null) {
    const bindingKey = `${k}Binding`
    return [`${toUpper(k)} :${bindingKey}`, {[bindingKey]: v}]
  }
}

export default class Query {
  constructor (knex, insertionPoints) {
    this.knex = client(knex)
    this._setInsertionPoints(insertionPoints)
    this._result = null
    this._resolved = false
  }

  _setInsertionPoints (insertionPoints) {
    this.insertionPoints = insertionPoints

    Object.keys(insertionPoints).forEach(
      k => {
        const v = insertionPoints[k]
        const store = `_${k}`

        if (typeof v === 'string') {
          this[store] = v
          return
        }
        else {
          this[store] = null
        }

        this[`${store}Bindings`] = {}

        const attachBindings = v => {
          if (Array.isArray(v)) {
            this[`${store}Bindings`] = {...v[1]}
            return v[0]
          }

          return v
        }

        if (typeof v === 'function') {
          this[k] = (...args) => {
            this[store] = attachBindings(v(k, ...args))
            return this
          }
        }
        else if (typeof v === 'object') {
          if (v.aggregate) {
            this[store] = []
            this[`${store}Joiner`] = v.joiner

            for (let o in v.aggregate) {
              const fn = v.aggregate[o]
              this[o] = (...args) => {
                const ov = attachBindings(fn(o, ...args))

                if (ov === null) {
                  this[store].splice(this[store].indexOf(ov), 1)
                }
                else {
                  if (this[store].indexOf(ov) === -1) {
                    this[store].push(ov)
                  }
                }

                return this
              }
            }
          }
          else if (v.options) {
            for (let o in v.options) {
              const fn = v.options[o]
              this[o] = (...args) => {
                this[store] = attachBindings(fn(o, ...args))
                return this
              }
            }
          }
        }
      }
    )
  }

  get sql () {
    const query = Object.keys(this.insertionPoints).filter(
      k => this[`_${k}`] !== null
    ).map(
      k =>
        Array.isArray(this[`_${k}`])
          ? this[`_${k}`].join(this[`_${k}Joiner`])
          : this[`_${k}`]
    )

    return query.join(' ')
  }

  get bindings () {
    const bindings = {}

    Object.keys(this.insertionPoints).filter(
      k => this[`_${k}Bindings`] !== void 0 && this[`_${k}Bindings`] !== null
    ).forEach(
      k => Object.assign(bindings, this[`_${k}Bindings`])
    )

    return bindings
  }

  then (...args) {
    if (this._resolved === false) {
      this._resolved = true
      this._result = this.knex.raw(this.sql, this.bindings)
    }

    return this._result.then(...args)
  }
}
