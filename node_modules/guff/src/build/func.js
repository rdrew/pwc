import emptyObj from 'empty/object'
import {client, log} from '../utils'
import getSchemaName from './getSchemaName'
import Query, {
  toUpper,
  safe,
  identifier,
  identifierBindings,
  conditionalBindings,
} from './Query'


const cache = {}

function createArgParams (args) {
  return `(${
    args.map(
      (a, i) => (
        `${a.IN ? 'IN' : a.OUT ? 'OUT' : ''}:name${i}: ` +
        `:type${i}:${a.default ? ` DEFAULT :default${i}:` : ''}`
      )
    ).join(',')
  })`
}

function createArgObj (args) {
  const argObj = {}

  args.forEach(
    (a, i) => {
      argObj[`name${i}`] = a.name
      argObj[`type${i}`] = a.type

      if (a.default) {
        argObj[`default${i}`] = a.default
      }
    }
  )

  return argObj
}

// NOTE: this only checks against function names in determining dupes,
// does not check argument types
export function doesFunctionExist (knex, name, opt = emptyObj) {
  const {schemaName = getSchemaName(knex)} = opt
  return knex.raw(
    `
      SELECT EXISTS(
        SELECT
          p.proname
        FROM
          pg_catalog.pg_proc p
        LEFT JOIN
          pg_catalog.pg_namespace n ON n.oid = p.pronamespace
        WHERE
          pg_catalog.pg_function_is_visible(p.oid)
          AND p.proname = ?
          AND n.nspname = ?
      );
    `,
    [name, schemaName]
  ).then(
    exists => {
      if (exists.rows && exists.rows.length) {
        exists = exists.rows[0].exists
        return exists
      }

      return false
    }
  )
}

export class Func extends Query {
  constructor (knex, name, proc) {
    super(knex, {
      create: 'CREATE',
      orReplace: toUpper,
      func: 'FUNCTION',
      name: identifier,
      args: (k, v) => {
        if (!v || !v.length) {
          return '()'
        }

        return [createArgParams(v), createArgObj(v)]
      },
      returns: identifierBindings,
      returnsTrigger: toUpper,
      returnsTable: conditionalBindings,
      as: 'AS',
      body: (k, v, bindings) => {
        if (v) {
          return [`$$\n${safe(v)}\n$$`, bindings || {}]
        }

        return v
      },
      language: 'LANGUAGE PLPGSQL',
      with: conditionalBindings
    })
    this.name(name)
    this.body(proc)
    this._resolved = false
    this._result = null
  }

  get sqlName () {
    return `
      ${this._nameBindings.nameBinding}${
        this.knex.raw(this._args, this._argsBindings).toSQL().sql.replace(
          /\s*DEFAULT[^,)]+?([,)])/g,
          '$1'
        )
      }
    `.trim()
  }

  then (...args) {
    if (this._resolved === false) {
      if (this._args === null) {
        this.args()
      }

      this._resolved = true
      const funcName = this._nameBindings.nameBinding
      this._result = doesFunctionExist(this.knex, funcName).then(
        exists => {
          if (exists === true) {
            log.warn(`function already exists:`, funcName)
            return exists
          }

          return this.knex.raw(this.sql, this.bindings).then(
            r => {
              log.success('created function:', this.sqlName)
              return r
            }
          )
        }
      )
    }

    return this._result.then(...args)
  }
}

export default function func (knex, name, body) {
  return new Func(knex, name, body)
}

export class DropFunc extends Query {
  constructor (knex, name) {
    super(knex, {
      create: 'DROP',
      trigger: 'FUNCTION',
      ifExists: toUpper,
      name: identifier,
      args: (k, v) => {
        if (!v || !v.length) {
          return '()'
        }

        v = v.map(a => ({...a, default: void 0}))
        return [createArgParams(v), createArgObj(v)]
      },
      cascade: toUpper,
      restrict: toUpper,
    })
    this.name(name)
  }

  get sqlName () {
    return `
      ${this._nameBindings.nameBinding}${
        this.knex.raw(this._args, this._argsBindings).toSQL().sql
      }
    `.trim()
  }

  then (...args) {
    if (this._args === null) {
      this.args()
    }

    return super.then(
      r => {
        log.success('dropped function:', this.sqlName)
        return r
      }
    ).then(...args)
  }
}

export function dropFunc (knex, name) {
  return new DropFunc(knex, name)
}
