import invariant from 'invariant'
import emptyObj from 'empty/object'
import check from './check'
import * as columns from './columns'


const proxyIgnore = ['setKnex', 'then', 'check', 'up', 'down']
const defaultChecks = {
  minLen: (check, {minLen}) =>
    !isNaN(minLen) && check.and(`char_length(:col:) >= :minLen:`, {minLen}),
  maxLen: (check, {maxLen}) =>
    !isNaN(maxLen) && check.and(`char_length(:col:) <= :maxLen:`, {maxLen}),
  minVal: (check, {minVal}) =>
    !isNaN(minVal) && check.and(`:col: >= :minVal:`, {minVal}),
  maxVal: (check, {maxVal}) =>
    !isNaN(maxVal) && check.and(`:col: <= :maxVal:`, {maxVal}),
}

class Column {
  constructor (knex, name, columnType, ...args) {
    this.knex = knex
    this.name = name
    this.columnType =
      typeof columnType === 'object' || !columnType ? name : columnType

    if (args.length === 0 || typeof args[0] === 'object' || !columnType) {
      this.args = [name, ...args]
    }

    this.column = columns[this.columnType]
    this.proxiedArgs = {}
    this.checkMap = {name: this.name}
    this.resolved = false
  }

  setKnex (knex) {
    this.knex = knex
    return this
  }

  proxy (name, args) {
    if (proxyIgnore.indexOf(name) > -1) {
      return this[name](...args)
    }
    else if (
      defaultChecks[name] !== void 0 || (
        this.column
        && this.column.check
        && this.column.check.indexOf(name) !== -1
      )
    ) {
      this.checkMap[name] = args
    }
    else {
      this.proxiedArgs[name] = args
    }

    return this
  }

  bindTable = table => {
    this.checkMap.table = table._tableName
    let out = table

    if (this.column === void 0) {
      if (table[this.columnType] === void 0) {
        out = table.specificType(this.name, this.columnType, ...this.args.slice(1))
      }
      else {
        out = table[this.columnType](...this.args)
      }
    }
    else {
      for (let key in this.column.args) {
        let val = this.column.args[key]
        val = typeof val === 'function' ? val(table, ...this.args) : val
        val = Array.isArray(val) ? val : [val]
        out = out[key](...val)
      }
    }

    for (let key in this.proxiedArgs) {
      out = out[key](...this.proxiedArgs[key])
    }

    return this
  }

  check (constraints) {
    return check(this.knex, this.table, this.name, constraints)
  }

  async after () {
    const mapKeys = Object.keys(this.checkMap)

    if (mapKeys.length > 0) {
      const checkColumn = check(this.knex, this.checkMap.table, this.name)

      mapKeys.forEach(
        k =>
          defaultChecks[k] !== void 0
          && defaultChecks[k](checkColumn, this.checkMap))

      if (checkColumn.constraints !== null) {
        await checkColumn
      }
    }

    if (this.column && this.column.after !== void 0) {
      return this.column.after(this.knex, {...this.checkMap, ...this.proxiedArgs})
    }

    return null
  }

  up (table) {
    this.resolved = true
    return column.up(
      this.knex,
      this.columnType,
      {
        name: this.name,
        table,
        ...this.proxiedArgs
      }
    )
  }

  down (table) {
    this.resolved = true
    return column.down(
      this.knex,
      this.columnType,
      {
        name: this.name,
        table,
        ...this.proxiedArgs
      }
    )
  }

  then (...args) {
    if (this.resolved === false) {
      this.resolved = true
      if (this.column === void 0 || this.column.up === void 0) {
        return Promise.resolve(this.bindTable).then(...args)
      }
      else {
        return this.column.up(this.knex, this.name, {...this.args, ...this.proxiedArgs}).then(
          () => this.bindTable
        ).then(...args)
      }
    }

    return Promise.resolve(this.bindTable).then(...args)
  }
}

export default function column (...args) {
  args = typeof args[0] === 'string' ? [null, ...args] : args
  const col = new Column(...args)

  return new Proxy(
    emptyObj,
    {
      get (target, name) {
        return function (...args) {
          col.proxy(name, args)
          return this
        }
      }
    }
  )
}

column.up = function (knex, columnType, ...args) {
  const col = columns[columnType]

  invariant(
    col !== void 0,
    `Column type '${columnType}' was not found in guff.column`
  )

  if (col.up) {
    return col.up(knex, ...args)
  }
}

column.down = function (knex, columnType, ...args) {
  const col = columns[columnType]

  invariant(
    col !== void 0,
    `Column type '${columnType}' was not found in guff.column`
  )

  if (col.down) {
    return col.down(knex, ...args)
  }
}
