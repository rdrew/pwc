'use strict'

var _interopRequireWildcard = require('@babel/runtime/helpers/interopRequireWildcard')

var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault')

exports.__esModule = true
exports.doesFunctionExist = doesFunctionExist
exports.default = func
exports.dropFunc = dropFunc
exports.DropFunc = exports.Func = void 0

var _objectSpread2 = _interopRequireDefault(
  require('@babel/runtime/helpers/objectSpread')
)

var _object = _interopRequireDefault(require('empty/object'))

var _utils = require('../utils')

var _getSchemaName = _interopRequireDefault(require('./getSchemaName'))

var _Query = _interopRequireWildcard(require('./Query'))

const cache = {}

function _ref(a, i) {
  return (
    `${a.IN ? 'IN' : a.OUT ? 'OUT' : ''}:name${i}: ` +
    `:type${i}:${a.default ? ` DEFAULT :default${i}:` : ''}`
  )
}

function createArgParams(args) {
  return `(${args.map(_ref).join(',')})`
}

function createArgObj(args) {
  const argObj = {}
  args.forEach((a, i) => {
    argObj[`name${i}`] = a.name
    argObj[`type${i}`] = a.type

    if (a.default) {
      argObj[`default${i}`] = a.default
    }
  })
  return argObj
} // NOTE: this only checks against function names in determining dupes,
// does not check argument types

function _ref2(exists) {
  if (exists.rows && exists.rows.length) {
    exists = exists.rows[0].exists
    return exists
  }

  return false
}

function doesFunctionExist(knex, name, opt = _object.default) {
  const {schemaName = (0, _getSchemaName.default)(knex)} = opt
  return knex
    .raw(
      `
      SELECT EXISTS(
        SELECT
          p.proname
        FROM
          pg_catalog.pg_proc p
        LEFT JOIN
          pg_catalog.pg_namespace n ON n.oid = p.pronamespace
        WHERE
          pg_catalog.pg_function_is_visible(p.oid)
          AND p.proname = ?
          AND n.nspname = ?
      );
    `,
      [name, schemaName]
    )
    .then(_ref2)
}

function _ref3(k, v) {
  if (!v || !v.length) {
    return '()'
  }

  return [createArgParams(v), createArgObj(v)]
}

function _ref4(k, v, bindings) {
  if (v) {
    return [`$$\n${(0, _Query.safe)(v)}\n$$`, bindings || {}]
  }

  return v
}

class Func extends _Query.default {
  constructor(knex, name, proc) {
    super(knex, {
      create: 'CREATE',
      orReplace: _Query.toUpper,
      func: 'FUNCTION',
      name: _Query.identifier,
      args: _ref3,
      returns: _Query.identifierBindings,
      returnsTrigger: _Query.toUpper,
      returnsTable: _Query.conditionalBindings,
      as: 'AS',
      body: _ref4,
      language: 'LANGUAGE PLPGSQL',
      with: _Query.conditionalBindings,
    })
    this.name(name)
    this.body(proc)
    this._resolved = false
    this._result = null
  }

  get sqlName() {
    return `
      ${this._nameBindings.nameBinding}${this.knex
      .raw(this._args, this._argsBindings)
      .toSQL()
      .sql.replace(/\s*DEFAULT[^,)]+?([,)])/g, '$1')}
    `.trim()
  }

  then(...args) {
    if (this._resolved === false) {
      if (this._args === null) {
        this.args()
      }

      this._resolved = true
      const funcName = this._nameBindings.nameBinding
      this._result = doesFunctionExist(this.knex, funcName).then(exists => {
        if (exists === true) {
          _utils.log.warn(`function already exists:`, funcName)

          return exists
        }

        return this.knex.raw(this.sql, this.bindings).then(r => {
          _utils.log.success('created function:', this.sqlName)

          return r
        })
      })
    }

    return this._result.then(...args)
  }
}

exports.Func = Func

function func(knex, name, body) {
  return new Func(knex, name, body)
}

function _ref5(a) {
  return (0, _objectSpread2.default)({}, a, {
    default: void 0,
  })
}

function _ref6(k, v) {
  if (!v || !v.length) {
    return '()'
  }

  v = v.map(_ref5)
  return [createArgParams(v), createArgObj(v)]
}

class DropFunc extends _Query.default {
  constructor(knex, name) {
    super(knex, {
      create: 'DROP',
      trigger: 'FUNCTION',
      ifExists: _Query.toUpper,
      name: _Query.identifier,
      args: _ref6,
      cascade: _Query.toUpper,
      restrict: _Query.toUpper,
    })
    this.name(name)
  }

  get sqlName() {
    return `
      ${this._nameBindings.nameBinding}${
      this.knex.raw(this._args, this._argsBindings).toSQL().sql
    }
    `.trim()
  }

  then(...args) {
    if (this._args === null) {
      this.args()
    }

    return super
      .then(r => {
        _utils.log.success('dropped function:', this.sqlName)

        return r
      })
      .then(...args)
  }
}

exports.DropFunc = DropFunc

function dropFunc(knex, name) {
  return new DropFunc(knex, name)
}
