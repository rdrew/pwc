'use strict'

var _interopRequireWildcard = require('@babel/runtime/helpers/interopRequireWildcard')

var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault')

exports.__esModule = true
exports.default = column

var _objectSpread2 = _interopRequireDefault(
  require('@babel/runtime/helpers/objectSpread')
)

var _invariant = _interopRequireDefault(require('invariant'))

var _object = _interopRequireDefault(require('empty/object'))

var _check = _interopRequireDefault(require('./check'))

var columns = _interopRequireWildcard(require('./columns'))

const proxyIgnore = ['setKnex', 'then', 'check', 'up', 'down']
const defaultChecks = {
  minLen: (check, {minLen}) =>
    !isNaN(minLen) &&
    check.and(`char_length(:col:) >= :minLen:`, {
      minLen,
    }),
  maxLen: (check, {maxLen}) =>
    !isNaN(maxLen) &&
    check.and(`char_length(:col:) <= :maxLen:`, {
      maxLen,
    }),
  minVal: (check, {minVal}) =>
    !isNaN(minVal) &&
    check.and(`:col: >= :minVal:`, {
      minVal,
    }),
  maxVal: (check, {maxVal}) =>
    !isNaN(maxVal) &&
    check.and(`:col: <= :maxVal:`, {
      maxVal,
    }),
}

class Column {
  constructor(knex, name, columnType, ...args) {
    this.bindTable = table => {
      this.checkMap.table = table._tableName
      let out = table

      if (this.column === void 0) {
        if (table[this.columnType] === void 0) {
          out = table.specificType(
            this.name,
            this.columnType,
            ...this.args.slice(1)
          )
        } else {
          out = table[this.columnType](...this.args)
        }
      } else {
        for (let key in this.column.args) {
          let val = this.column.args[key]
          val = typeof val === 'function' ? val(table, ...this.args) : val
          val = Array.isArray(val) ? val : [val]
          out = out[key](...val)
        }
      }

      for (let key in this.proxiedArgs) {
        out = out[key](...this.proxiedArgs[key])
      }

      return this
    }

    this.knex = knex
    this.name = name
    this.columnType =
      typeof columnType === 'object' || !columnType ? name : columnType

    if (args.length === 0 || typeof args[0] === 'object' || !columnType) {
      this.args = [name, ...args]
    }

    this.column = columns[this.columnType]
    this.proxiedArgs = {}
    this.checkMap = {
      name: this.name,
    }
    this.resolved = false
  }

  setKnex(knex) {
    this.knex = knex
    return this
  }

  proxy(name, args) {
    if (proxyIgnore.indexOf(name) > -1) {
      return this[name](...args)
    } else if (
      defaultChecks[name] !== void 0 ||
      (this.column &&
        this.column.check &&
        this.column.check.indexOf(name) !== -1)
    ) {
      this.checkMap[name] = args
    } else {
      this.proxiedArgs[name] = args
    }

    return this
  }

  check(constraints) {
    return (0, _check.default)(this.knex, this.table, this.name, constraints)
  }

  async after() {
    const mapKeys = Object.keys(this.checkMap)

    if (mapKeys.length > 0) {
      const checkColumn = (0, _check.default)(
        this.knex,
        this.checkMap.table,
        this.name
      )
      mapKeys.forEach(
        k =>
          defaultChecks[k] !== void 0 &&
          defaultChecks[k](checkColumn, this.checkMap)
      )

      if (checkColumn.constraints !== null) {
        await checkColumn
      }
    }

    if (this.column && this.column.after !== void 0) {
      return this.column.after(
        this.knex,
        (0, _objectSpread2.default)({}, this.checkMap, this.proxiedArgs)
      )
    }

    return null
  }

  up(table) {
    this.resolved = true
    return column.up(
      this.knex,
      this.columnType,
      (0, _objectSpread2.default)(
        {
          name: this.name,
          table,
        },
        this.proxiedArgs
      )
    )
  }

  down(table) {
    this.resolved = true
    return column.down(
      this.knex,
      this.columnType,
      (0, _objectSpread2.default)(
        {
          name: this.name,
          table,
        },
        this.proxiedArgs
      )
    )
  }

  then(...args) {
    if (this.resolved === false) {
      this.resolved = true

      if (this.column === void 0 || this.column.up === void 0) {
        return Promise.resolve(this.bindTable).then(...args)
      } else {
        return this.column
          .up(
            this.knex,
            this.name,
            (0, _objectSpread2.default)({}, this.args, this.proxiedArgs)
          )
          .then(() => this.bindTable)
          .then(...args)
      }
    }

    return Promise.resolve(this.bindTable).then(...args)
  }
}

function column(...args) {
  args = typeof args[0] === 'string' ? [null, ...args] : args
  const col = new Column(...args)
  return new Proxy(_object.default, {
    get(target, name) {
      return function(...args) {
        col.proxy(name, args)
        return this
      }
    },
  })
}

column.up = function(knex, columnType, ...args) {
  const col = columns[columnType]
  !(col !== void 0)
    ? process.env.NODE_ENV !== 'production'
      ? (0, _invariant.default)(
          false,
          `Column type '${columnType}' was not found in guff.column`
        )
      : invariant(false)
    : void 0

  if (col.up) {
    return col.up(knex, ...args)
  }
}

column.down = function(knex, columnType, ...args) {
  const col = columns[columnType]
  !(col !== void 0)
    ? process.env.NODE_ENV !== 'production'
      ? (0, _invariant.default)(
          false,
          `Column type '${columnType}' was not found in guff.column`
        )
      : invariant(false)
    : void 0

  if (col.down) {
    return col.down(knex, ...args)
  }
}
