'use strict'

var _interopRequireWildcard = require('@babel/runtime/helpers/interopRequireWildcard')

var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault')

exports.__esModule = true
exports.default = trigger
exports.dropTrigger = dropTrigger
exports.DropTrigger = exports.Trigger = void 0

var _object = _interopRequireDefault(require('empty/object'))

var _utils = require('../utils')

var _Query = _interopRequireWildcard(require('./Query'))

function _ref() {
  return 'FOR EACH ROW'
}

function _ref2() {
  return 'FOR EACH STATEMENT'
}

class Trigger extends _Query.default {
  constructor(knex, name, proc) {
    super(knex, {
      create: 'CREATE',
      constraint: _Query.toUpper,
      trigger: 'TRIGGER',
      name: _Query.identifier,
      whenEvent: {
        options: {
          before: _Query.toUpper,
          after: _Query.toUpper,
          insteadOf: _Query.toUpper,
        },
      },
      event: {
        joiner: ' OR ',
        aggregate: {
          insert: _Query.toUpper,
          update: _Query.toUpper,
          delete: _Query.toUpper,
          truncate: _Query.toUpper,
        },
      },
      on: _Query.identifierBindings,
      from: _Query.identifierBindings,
      timing: {
        options: {
          notDeferrable: _Query.toUpper,
          deferrable: _Query.toUpper,
          initiallyImmediate: _Query.toUpper,
          initiallyDeferred: _Query.toUpper,
        },
      },
      forEach: {
        options: {
          eachRow: _ref,
          eachStmt: _ref2,
        },
      },
      when: _Query.conditionalBindings,
      executeProcedure: _Query.identifierBindings,
    })
    this.name(name)
    this.executeProcedure(proc)
  }

  get sqlName() {
    return this._nameBindings.nameBinding
  }

  then(...args) {
    return super
      .then(r => {
        _utils.log.success('created trigger:', this.sqlName)

        return r
      })
      .then(...args)
  }
}

exports.Trigger = Trigger

function makeName(name) {
  return `${name.split('(')[0].trim()}_trigger`
}

function trigger(knex, name, proc) {
  if (name === void 0) {
    proc = knex.sqlName
    name = makeName(proc)
    knex = knex.knex
    proc = knex.raw(proc)
  }

  if (proc === void 0) {
    proc = name
    proc = typeof proc === 'string' ? proc : proc.sqlName
    proc = knex.raw(proc)
    name = makeName(name)
  }

  return new Trigger(knex, name, proc)
}

class DropTrigger extends _Query.default {
  constructor(knex, name) {
    super(knex, {
      create: 'DROP',
      trigger: 'TRIGGER',
      ifExists: _Query.toUpper,
      name: _Query.identifier,
      on: _Query.identifierBindings,
      cascade: _Query.toUpper,
      restrict: _Query.toUpper,
    })
    this.name(name)
  }

  get sqlName() {
    return this._nameBindings.nameBinding
  }

  then(...args) {
    return super
      .then(r => {
        _utils.log.success('dropped trigger:', this.sqlName)

        return r
      })
      .then(...args)
  }
}

exports.DropTrigger = DropTrigger

function dropTrigger(knex, name) {
  return new DropTrigger(knex, name)
}
