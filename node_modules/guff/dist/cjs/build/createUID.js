'use strict'

var _interopRequireWildcard = require('@babel/runtime/helpers/interopRequireWildcard')

var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault')

exports.__esModule = true
exports.default = createUID
exports.createUIDSeq = createUIDSeq
exports.dropUID = dropUID
exports.createKnownUIDTable = createKnownUIDTable
exports.dropKnownUIDTable = dropKnownUIDTable
exports.createKnownUIDTrigger = createKnownUIDTrigger
exports.dropKnownUIDTrigger = dropKnownUIDTrigger

var _object = _interopRequireDefault(require('empty/object'))

var _invariant = _interopRequireDefault(require('invariant'))

var _utils = require('../utils')

var _getSchemaName = _interopRequireDefault(require('./getSchemaName'))

var _createTable = _interopRequireWildcard(require('./createTable'))

var _column = _interopRequireDefault(require('./column'))

var _trigger = _interopRequireWildcard(require('./trigger'))

var _sequence = _interopRequireWildcard(require('./sequence'))

var _func = _interopRequireWildcard(require('./func'))

// sets date to 1 day ago to avoid negative numbers do to clock shifts
const date = Date.now() - 86400 * 1000
const cache = {}
const body = `
-- The shard ID, must be unique for each shard
DECLARE
    -- !! custom epoch, this will work for 41 years after the epoch
    start_epoch bigint := :epoch:;
    -- Declares big integer variables we will use to calculate the uuid
    seq_id bigint;
    now_millis bigint;
    result bigint;
BEGIN
    -- Selects the next value of the sequence we created earlier
    -- and performs a modulus operator on it so that it fits in to
    -- 10 bits (this is where the 1024 comes from).
    SELECT mod(nextval(':seqName:'), 1024) INTO seq_id;
SELECT FLOOR(EXTRACT(EPOCH FROM clock_timestamp()) * 1000) INTO now_millis;
    -- left shifts 41 bits (64 - 41)
    result := (now_millis - start_epoch) << 23;
    -- left shifts 13 bits (64 - 41 - 13)
    result := result | (shard_id << 10);
    -- fills remaining 10 bits (from the modulus operation above)
    result := result | (seq_id);
    RETURN result;
END;
`
const uidArgs = [
  {
    name: 'shard_id',
    type: 'int4',
    default: 1,
  },
]
/**
========================================================================
Creates a 64-bit universally unique id. This is accomplished by
calculating a 41-bit representation of the milliseconds from a given
start epoch, using a 13-bit representation of the ID number of the
shard, and a 10-bit representation of a global ID sequence for a given
schema.
------------------------------------------------------------------------
The UID can be sorted by its insertion order, that is, rows submitted
sequentially will remain sequential in terms of their UID.
------------------------------------------------------------------------
64-bit UID is delegated like so:
* 41-bit time in milliseconds since epoch (gives 41 years of IDs)
* 13-bit logical shard ID
* 10-bit representation of an auto-incrementing sequence, modulus 1024.
    This means we can generate 1024 IDs, per shard, per millisecond.
========================================================================
A modulus operation works like this:
1. Say the 'nextval' is 5061 and the modulo is 1024
    |5061 % 1024|
2. Divide 'nextval' by the modulo (1024 in this case)
    |5061 / 1024 = 4.942|
3. Multiply the INTEGER value of step 2 by the modulo (1024)
    |INT 4.942 = 4|
    |4 * 1024 = 4096|
4. Subtract step 3 from 'nextval' to get the difference,
    this is the result of the operation
    |5061 - 4096 = 965|
|Result: 5061 % 1024 = 965|
The maximum number in 10 bits is 1024.  Therefore, by taking the modulo
of the sequence ids, we always get a number which is between 1 and
1024. If we wanted the number to fit in an 8 bit representation we
could set the modulo to 256.
========================================================================
At scale, simply find/replace out {schema} for each shard you have.
To use, set the |uid| field default value to |{schema}.cargo_uid()|
where X is the shard ID. The |uid| field must be of type BIGINT (int8)
in order to work properly as an integer field. It could still be placed
in a text field, etc.
Credit to:
http://rob.conery.io/2014/05/29/a-better-id-generator-for-postgresql/
*/

async function createUID(knex, opt = _object.default) {
  !(knex !== void 0)
    ? process.env.NODE_ENV !== 'production'
      ? (0, _invariant.default)(
          false,
          `createUID function requires that you provide a knex instance ` +
            `as the first argument`
        )
      : invariant(false)
    : void 0
  let {
    name = 'guff_uid',
    epoch = date,
    seqCache = 1024,
    seqName = 'guff_uid_seq',
  } = opt
  const schemaName = (0, _getSchemaName.default)(knex)
  const key = JSON.stringify({
    name,
    epoch,
    seqCache,
    seqName,
    schemaName,
  })

  if (cache[key] === void 0) {
    await createUIDSeq(knex, name, seqCache)
    cache[key] = (0, _func.default)(knex, name)
      .body(body, {
        epoch,
        seqName: `${schemaName}.${seqName}`,
      })
      .args(uidArgs)
      .returns('int8')
  }

  return cache[key]
}

function createUIDSeq(knex, name, cacheSize = 1000) {
  return (0, _sequence.default)(knex, `${name}_seq`)
    .ifNotExists()
    .noMinvalue()
    .noMaxvalue()
    .cache(cacheSize)
}

async function dropUID(knex, name = 'guff_uid') {
  const dropped = (0, _func.dropFunc)(knex, name)
    .args(uidArgs)
    .ifExists()
    .cascade()
  await (0, _sequence.dropSequence)(knex, name)
    .ifExists()
    .cascade()
  return dropped
}

function createKnownUIDTable(knex) {
  return (0, _createTable.default)(knex, 'guff_known_uid', [
    (0, _column.default)('uid', 'bigInteger')
      .defaultTo(null)
      .primary(),
    (0, _column.default)('ref', 'text').notNullable(),
  ])
}

function dropKnownUIDTable(knex) {
  return (0, _createTable.dropTable)(knex, 'guff_known_uid')
}

const getInsertKnownUIDFunc = columnName => `
BEGIN
  INSERT INTO guff_known_uid (uid, ref) VALUES (NEW.${columnName}, TG_TABLE_NAME);
  RETURN NULL;
END;
`

const getDeleteKnownUIDFunc = columnName => `
BEGIN
  DELETE FROM guff_known_uid WHERE uid = OLD.${columnName};
  RETURN NULL;
END;
`

const getKnownInsertName = (table, columnName) =>
  `guff_insert_${table}_${columnName}`

const getKnownDeleteName = (table, columnName) =>
  `guff_delete_${table}_${columnName}`

async function createKnownUIDTrigger(knex, table, columnName) {
  const insertName = getKnownInsertName(table, columnName)
  const insertFn = (0, _func.default)(
    knex,
    insertName,
    getInsertKnownUIDFunc(columnName)
  ).returnsTrigger()
  const deleteName = getKnownDeleteName(table, columnName)
  const deleteFn = (0, _func.default)(
    knex,
    deleteName,
    getDeleteKnownUIDFunc(columnName)
  ).returnsTrigger()
  await Promise.all([insertFn, deleteFn])
  return await Promise.all([
    (0, _trigger.default)(insertFn)
      .on(table)
      .eachRow()
      .after()
      .insert(),
    (0, _trigger.default)(deleteFn)
      .on(table)
      .eachRow()
      .after()
      .delete(),
  ])
}

async function dropKnownUIDTrigger(knex, table, columnName) {
  const insertName = getKnownInsertName(table, columnName)
  const droppedInsert = (0, _func.dropFunc)(knex, insertName)
    .ifExists()
    .cascade()
  const deleteName = getKnownDeleteName(table, columnName)
  const droppedDelete = (0, _func.dropFunc)(knex, deleteName)
    .ifExists()
    .cascade()
  await Promise.all([
    (0, _trigger.dropTrigger)(knex, `${insertName}_trigger`)
      .ifExists()
      .on(table),
    (0, _trigger.dropTrigger)(knex, `${deleteName}_trigger`)
      .ifExists()
      .on(table),
  ])
  return await Promise.all([droppedInsert, droppedDelete])
}
