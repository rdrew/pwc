'use strict'

var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault')

exports.__esModule = true
exports.toUpper = toUpper
exports.safe = safe
exports.identifier = identifier
exports.identifierBindings = identifierBindings
exports.conditionalBindings = conditionalBindings
exports.default = void 0

var _objectSpread2 = _interopRequireDefault(
  require('@babel/runtime/helpers/objectSpread')
)

var _utils = require('../utils')

const upperRepl = /([A-Z]+)/g

function toUpper(k, v) {
  if (v === false) {
    return null
  }

  return k.replace(upperRepl, ' $1').toUpperCase()
}

function safe(v) {
  return v
}

function identifier(k, v) {
  if (v !== void 0 && v !== null) {
    const bindingKey = `${k}Binding`
    return [
      `:${bindingKey}:`,
      {
        [bindingKey]: v,
      },
    ]
  }
}

function identifierBindings(k, v) {
  if (v !== void 0 && v !== null) {
    const bindingKey = `${k}Binding`
    return [
      `${toUpper(k)} :${bindingKey}:`,
      {
        [bindingKey]: v,
      },
    ]
  }
}

function conditionalBindings(k, v) {
  if (v !== void 0 && v !== null) {
    const bindingKey = `${k}Binding`
    return [
      `${toUpper(k)} :${bindingKey}`,
      {
        [bindingKey]: v,
      },
    ]
  }
}

class Query {
  constructor(knex, insertionPoints) {
    this.knex = (0, _utils.client)(knex)

    this._setInsertionPoints(insertionPoints)

    this._result = null
    this._resolved = false
  }

  _setInsertionPoints(insertionPoints) {
    this.insertionPoints = insertionPoints
    Object.keys(insertionPoints).forEach(k => {
      const v = insertionPoints[k]
      const store = `_${k}`

      if (typeof v === 'string') {
        this[store] = v
        return
      } else {
        this[store] = null
      }

      this[`${store}Bindings`] = {}

      const attachBindings = v => {
        if (Array.isArray(v)) {
          this[`${store}Bindings`] = (0, _objectSpread2.default)({}, v[1])
          return v[0]
        }

        return v
      }

      if (typeof v === 'function') {
        this[k] = (...args) => {
          this[store] = attachBindings(v(k, ...args))
          return this
        }
      } else if (typeof v === 'object') {
        if (v.aggregate) {
          this[store] = []
          this[`${store}Joiner`] = v.joiner

          for (let o in v.aggregate) {
            const fn = v.aggregate[o]

            this[o] = (...args) => {
              const ov = attachBindings(fn(o, ...args))

              if (ov === null) {
                this[store].splice(this[store].indexOf(ov), 1)
              } else {
                if (this[store].indexOf(ov) === -1) {
                  this[store].push(ov)
                }
              }

              return this
            }
          }
        } else if (v.options) {
          for (let o in v.options) {
            const fn = v.options[o]

            this[o] = (...args) => {
              this[store] = attachBindings(fn(o, ...args))
              return this
            }
          }
        }
      }
    })
  }

  get sql() {
    const query = Object.keys(this.insertionPoints)
      .filter(k => this[`_${k}`] !== null)
      .map(
        k =>
          Array.isArray(this[`_${k}`])
            ? this[`_${k}`].join(this[`_${k}Joiner`])
            : this[`_${k}`]
      )
    return query.join(' ')
  }

  get bindings() {
    const bindings = {}
    Object.keys(this.insertionPoints)
      .filter(
        k => this[`_${k}Bindings`] !== void 0 && this[`_${k}Bindings`] !== null
      )
      .forEach(k => Object.assign(bindings, this[`_${k}Bindings`]))
    return bindings
  }

  then(...args) {
    if (this._resolved === false) {
      this._resolved = true
      this._result = this.knex.raw(this.sql, this.bindings)
    }

    return this._result.then(...args)
  }
}

exports.default = Query
