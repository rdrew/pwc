import _regeneratorRuntime from '@babel/runtime/regenerator'
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator'
import {client} from '../../utils'
import trigger, {dropTrigger} from '../trigger'
import func, {dropFunc} from '../func'
export var args = {
  timestamp: function timestamp(knex, name) {
    return name
  },
  defaultTo: function defaultTo(knex) {
    return client(knex).raw('NOW()')
  },
  notNullable: [],
}
var updateTrigger =
  '\nBEGIN\n  NEW.:updateFieldName: = now();\n  RETURN NEW;\nEND;\n'

function _callee3(knex, _ref) {
  var name, table, fn
  return _regeneratorRuntime.wrap(
    function _callee$(_context) {
      while (1) {
        switch ((_context.prev = _context.next)) {
          case 0:
            ;(name = _ref.name), (table = _ref.table)
            fn = func(knex, 'guff_update_' + name)
              .body(updateTrigger, {
                updateFieldName: name,
              })
              .returnsTrigger()
            _context.next = 4
            return fn

          case 4:
            _context.next = 6
            return trigger(fn)
              .on(table)
              .eachRow()
              .before()
              .update()

          case 6:
            return _context.abrupt('return', _context.sent)

          case 7:
          case 'end':
            return _context.stop()
        }
      }
    },
    _callee3,
    this
  )
}

export var after =
  /*#__PURE__*/
  (function() {
    var _ref2 = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(_callee3)
    )

    return function after(_x, _x2) {
      return _ref2.apply(this, arguments)
    }
  })()

function _callee4(knex, _ref3) {
  var name, table, trigger
  return _regeneratorRuntime.wrap(
    function _callee2$(_context2) {
      while (1) {
        switch ((_context2.prev = _context2.next)) {
          case 0:
            ;(name = _ref3.name), (table = _ref3.table)
            name = 'guff_update_' + name
            _context2.next = 4
            return dropTrigger(knex, name + '_trigger')
              .on(table)
              .ifExists()
              .cascade()

          case 4:
            trigger = _context2.sent
            _context2.next = 7
            return dropFunc(knex, name)
              .ifExists()
              .cascade()

          case 7:
            return _context2.abrupt('return', trigger)

          case 8:
          case 'end':
            return _context2.stop()
        }
      }
    },
    _callee4,
    this
  )
}

export var down =
  /*#__PURE__*/
  (function() {
    var _ref4 = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(_callee4)
    )

    return function down(_x3, _x4) {
      return _ref4.apply(this, arguments)
    }
  })()
