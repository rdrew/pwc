import _regeneratorRuntime from '@babel/runtime/regenerator'
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator'
import {client, trimAll} from '../../utils'
import createKey, {dropKey} from '../createKey'
import extension, {dropExtension} from '../extension'
import getSchemaName from '../getSchemaName'

function _callee3(knex) {
  return _regeneratorRuntime.wrap(
    function _callee$(_context) {
      while (1) {
        switch ((_context.prev = _context.next)) {
          case 0:
            _context.next = 2
            return extension(knex, 'pgcrypto')
              .ifNotExists()
              .schema(getSchemaName(knex))

          case 2:
            _context.next = 4
            return createKey(knex)

          case 4:
          case 'end':
            return _context.stop()
        }
      }
    },
    _callee3,
    this
  )
}

export var up =
  /*#__PURE__*/
  (function() {
    var _ref = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(_callee3)
    )

    return function up(_x) {
      return _ref.apply(this, arguments)
    }
  })()

function _callee4(knex, opt) {
  return _regeneratorRuntime.wrap(
    function _callee2$(_context2) {
      while (1) {
        switch ((_context2.prev = _context2.next)) {
          case 0:
            _context2.next = 2
            return dropExtension(knex, 'pgcrypto')
              .ifExists()
              .cascade()

          case 2:
            _context2.next = 4
            return dropKey(knex, opt && opt.name)

          case 4:
          case 'end':
            return _context2.stop()
        }
      }
    },
    _callee4,
    this
  )
}

export var down =
  /*#__PURE__*/
  (function() {
    var _ref2 = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(_callee4)
    )

    return function down(_x2, _x3) {
      return _ref2.apply(this, arguments)
    }
  })()
export var args = {
  specificType: function specificType(knex, name) {
    return [name, 'text']
  },
  defaultTo: function defaultTo(knex, name, opt) {
    return client(knex).raw('guff_key(?)', opt && opt.length ? opt.length : 24)
  },
  notNullable: [],
  comment: trimAll(
    '\n    Creates a cryptographically secure key that can be used for things like\n    validating user sessions.\n  '
  ),
}
