import emptyObj from 'empty/object'
import emptyArr from 'empty/array'
import {client, schema, log} from '../utils'
import {getSchemaNames} from './getSchemaName' // DO NOT EXPOSE TO USERS

export function dropSchema(knex, opt) {
  if (opt === void 0) {
    opt = emptyObj
  }

  var _opt = opt,
    _opt$ifExists = _opt.ifExists,
    ifExists = _opt$ifExists === void 0 ? true : _opt$ifExists,
    _opt$ignore = _opt.ignore,
    ignore = _opt$ignore === void 0 ? emptyArr : _opt$ignore
  var schemaNames = getSchemaNames(knex)
  var schemas = []

  var _loop = function _loop() {
    if (_isArray) {
      if (_i >= _iterator.length) return 'break'
      _ref = _iterator[_i++]
    } else {
      _i = _iterator.next()
      if (_i.done) return 'break'
      _ref = _i.value
    }

    var schemaName = _ref

    function _ref3(r) {
      log.success('dropped schema:', schemaName)
      return r
    }

    if (schemaName !== 'public' && opt.ignore.indexOf(schemaName) === -1) {
      // knex's internal dropSchema doesn't cascade
      schemas.push(
        client(knex)
          .raw(
            'DROP SCHEMA ' + (ifExists ? 'IF EXISTS' : '') + ' ?? CASCADE',
            schemaName
          )
          .then(_ref3)
      )
    }
  }

  for (
    var _iterator = schemaNames,
      _isArray = Array.isArray(_iterator),
      _i = 0,
      _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
    ;

  ) {
    var _ref

    var _ret = _loop()

    if (_ret === 'break') break
  }

  return Promise.all(schemas)
} // DO NOT EXPOSE TO USERS

export default function createSchema(knex, opt) {
  if (opt === void 0) {
    opt = emptyObj
  }

  var _opt2 = opt,
    _opt2$ifNotExists = _opt2.ifNotExists,
    ifNotExists = _opt2$ifNotExists === void 0 ? true : _opt2$ifNotExists,
    _opt2$ignore = _opt2.ignore,
    ignore = _opt2$ignore === void 0 ? [] : _opt2$ignore,
    authorization = _opt2.authorization
  var schemaNames = getSchemaNames(knex)
  var schemas = []

  var _loop2 = function _loop2() {
    if (_isArray2) {
      if (_i2 >= _iterator2.length) return 'break'
      _ref2 = _iterator2[_i2++]
    } else {
      _i2 = _iterator2.next()
      if (_i2.done) return 'break'
      _ref2 = _i2.value
    }

    var schemaName = _ref2

    function _ref4(r) {
      log.success('created schema:', schemaName)
      return r
    }

    if (schemaName !== 'public' && opt.ignore.indexOf(schemaName) === -1) {
      var fn = ifNotExists ? 'createSchemaIfNotExists' : 'createSchema'
      schemas.push(
        schema(knex)
          [fn](schemaName)
          .then(_ref4)
      )
    }
  }

  for (
    var _iterator2 = schemaNames,
      _isArray2 = Array.isArray(_iterator2),
      _i2 = 0,
      _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();
    ;

  ) {
    var _ref2

    var _ret2 = _loop2()

    if (_ret2 === 'break') break
  }

  return Promise.all(schemas)
}
