import _construct from '@babel/runtime/helpers/construct'
import _regeneratorRuntime from '@babel/runtime/regenerator'
import _objectSpread from '@babel/runtime/helpers/objectSpread'
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator'
import invariant from 'invariant'
import emptyObj from 'empty/object'
import _check from './check'
import * as columns from './columns'
var proxyIgnore = ['setKnex', 'then', 'check', 'up', 'down']
var defaultChecks = {
  minLen: function minLen(check, _ref) {
    var _minLen = _ref.minLen
    return (
      !isNaN(_minLen) &&
      check.and('char_length(:col:) >= :minLen:', {
        minLen: _minLen,
      })
    )
  },
  maxLen: function maxLen(check, _ref2) {
    var _maxLen = _ref2.maxLen
    return (
      !isNaN(_maxLen) &&
      check.and('char_length(:col:) <= :maxLen:', {
        maxLen: _maxLen,
      })
    )
  },
  minVal: function minVal(check, _ref3) {
    var _minVal = _ref3.minVal
    return (
      !isNaN(_minVal) &&
      check.and(':col: >= :minVal:', {
        minVal: _minVal,
      })
    )
  },
  maxVal: function maxVal(check, _ref4) {
    var _maxVal = _ref4.maxVal
    return (
      !isNaN(_maxVal) &&
      check.and(':col: <= :maxVal:', {
        maxVal: _maxVal,
      })
    )
  },
}

function _Column(knex, name, columnType) {
  var _this = this

  this.bindTable = function(table) {
    _this.checkMap.table = table._tableName
    var out = table

    if (_this.column === void 0) {
      if (table[_this.columnType] === void 0) {
        out = table.specificType.apply(
          table,
          [_this.name, _this.columnType].concat(_this.args.slice(1))
        )
      } else {
        out = table[_this.columnType].apply(table, _this.args)
      }
    } else {
      for (var key in _this.column.args) {
        var _out

        var val = _this.column.args[key]
        val =
          typeof val === 'function'
            ? val.apply(void 0, [table].concat(_this.args))
            : val
        val = Array.isArray(val) ? val : [val]
        out = (_out = out)[key].apply(_out, val)
      }
    }

    for (var _key2 in _this.proxiedArgs) {
      var _out2

      out = (_out2 = out)[_key2].apply(_out2, _this.proxiedArgs[_key2])
    }

    return _this
  }

  this.knex = knex
  this.name = name
  this.columnType =
    typeof columnType === 'object' || !columnType ? name : columnType

  for (
    var _len = arguments.length,
      args = new Array(_len > 3 ? _len - 3 : 0),
      _key = 3;
    _key < _len;
    _key++
  ) {
    args[_key - 3] = arguments[_key]
  }

  if (args.length === 0 || typeof args[0] === 'object' || !columnType) {
    this.args = [name].concat(args)
  }

  this.column = columns[this.columnType]
  this.proxiedArgs = {}
  this.checkMap = {
    name: this.name,
  }
  this.resolved = false
}

function _setKnex(knex) {
  this.knex = knex
  return this
}

function _proxy(name, args) {
  if (proxyIgnore.indexOf(name) > -1) {
    return this[name].apply(this, args)
  } else if (
    defaultChecks[name] !== void 0 ||
    (this.column && this.column.check && this.column.check.indexOf(name) !== -1)
  ) {
    this.checkMap[name] = args
  } else {
    this.proxiedArgs[name] = args
  }

  return this
}

function _check2(constraints) {
  return _check(this.knex, this.table, this.name, constraints)
}

function _callee2() {
  var _this2 = this

  var mapKeys, checkColumn

  function _ref5(k) {
    return (
      defaultChecks[k] !== void 0 &&
      defaultChecks[k](checkColumn, _this2.checkMap)
    )
  }

  return _regeneratorRuntime.wrap(
    function _callee$(_context) {
      while (1) {
        switch ((_context.prev = _context.next)) {
          case 0:
            mapKeys = Object.keys(this.checkMap)

            if (!(mapKeys.length > 0)) {
              _context.next = 7
              break
            }

            checkColumn = _check(this.knex, this.checkMap.table, this.name)
            mapKeys.forEach(_ref5)

            if (!(checkColumn.constraints !== null)) {
              _context.next = 7
              break
            }

            _context.next = 7
            return checkColumn

          case 7:
            if (!(this.column && this.column.after !== void 0)) {
              _context.next = 9
              break
            }

            return _context.abrupt(
              'return',
              this.column.after(
                this.knex,
                _objectSpread({}, this.checkMap, this.proxiedArgs)
              )
            )

          case 9:
            return _context.abrupt('return', null)

          case 10:
          case 'end':
            return _context.stop()
        }
      }
    },
    _callee2,
    this
  )
}

function _ref6() {
  var _after = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(_callee2)
  )

  return function after() {
    return _after.apply(this, arguments)
  }
}

function _up(table) {
  this.resolved = true
  return column.up(
    this.knex,
    this.columnType,
    _objectSpread(
      {
        name: this.name,
        table: table,
      },
      this.proxiedArgs
    )
  )
}

function _down(table) {
  this.resolved = true
  return column.down(
    this.knex,
    this.columnType,
    _objectSpread(
      {
        name: this.name,
        table: table,
      },
      this.proxiedArgs
    )
  )
}

function _then() {
  var _this3 = this,
    _Promise$resolve2

  function _ref7() {
    return _this3.bindTable
  }

  if (this.resolved === false) {
    this.resolved = true

    if (this.column === void 0 || this.column.up === void 0) {
      var _Promise$resolve

      return (_Promise$resolve = Promise.resolve(this.bindTable)).then.apply(
        _Promise$resolve,
        arguments
      )
    } else {
      var _this$column$up$then

      return (_this$column$up$then = this.column
        .up(
          this.knex,
          this.name,
          _objectSpread({}, this.args, this.proxiedArgs)
        )
        .then(_ref7)).then.apply(_this$column$up$then, arguments)
    }
  }

  return (_Promise$resolve2 = Promise.resolve(this.bindTable)).then.apply(
    _Promise$resolve2,
    arguments
  )
}

var Column =
  /*#__PURE__*/
  (function() {
    var _proto = _Column.prototype
    _proto.setKnex = _setKnex
    _proto.proxy = _proxy
    _proto.check = _check2
    _proto.after =
      /*#__PURE__*/
      _ref6()
    _proto.up = _up
    _proto.down = _down
    _proto.then = _then
    return _Column
  })()

export default function column() {
  for (
    var _len2 = arguments.length, args = new Array(_len2), _key3 = 0;
    _key3 < _len2;
    _key3++
  ) {
    args[_key3] = arguments[_key3]
  }

  args = typeof args[0] === 'string' ? [null].concat(args) : args

  var col = _construct(Column, args)

  return new Proxy(emptyObj, {
    get: function get(target, name) {
      return function() {
        for (
          var _len3 = arguments.length, args = new Array(_len3), _key4 = 0;
          _key4 < _len3;
          _key4++
        ) {
          args[_key4] = arguments[_key4]
        }

        col.proxy(name, args)
        return this
      }
    },
  })
}

column.up = function(knex, columnType) {
  var col = columns[columnType]
  !(col !== void 0)
    ? process.env.NODE_ENV !== 'production'
      ? invariant(
          false,
          "Column type '" + columnType + "' was not found in guff.column"
        )
      : invariant(false)
    : void 0

  if (col.up) {
    for (
      var _len4 = arguments.length,
        args = new Array(_len4 > 2 ? _len4 - 2 : 0),
        _key5 = 2;
      _key5 < _len4;
      _key5++
    ) {
      args[_key5 - 2] = arguments[_key5]
    }

    return col.up.apply(col, [knex].concat(args))
  }
}

column.down = function(knex, columnType) {
  var col = columns[columnType]
  !(col !== void 0)
    ? process.env.NODE_ENV !== 'production'
      ? invariant(
          false,
          "Column type '" + columnType + "' was not found in guff.column"
        )
      : invariant(false)
    : void 0

  if (col.down) {
    for (
      var _len5 = arguments.length,
        args = new Array(_len5 > 2 ? _len5 - 2 : 0),
        _key6 = 2;
      _key6 < _len5;
      _key6++
    ) {
      args[_key6 - 2] = arguments[_key6]
    }

    return col.down.apply(col, [knex].concat(args))
  }
}
