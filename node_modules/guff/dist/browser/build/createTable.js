import _regeneratorRuntime from '@babel/runtime/regenerator'
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator'
import emptyArr from 'empty/array'
import {schema, log} from '../utils'
import getSchemaName from './getSchemaName'
export default function createTable(_x, _x2, _x3) {
  return _createTable.apply(this, arguments)
}

function _ref5(c) {
  return c.after()
}

function _callee3(knex, tableName, columns) {
  var tableColumns

  function _ref(c) {
    return c.setKnex(knex)
  }

  function _ref3(r) {
    log.success('created table:', tableName)
    return r
  }

  function _ref4(cols) {
    function _ref2(t) {
      return (tableColumns = cols.map(function(c) {
        return c(t)
      }))
    }

    return schema(knex)
      .hasTable(tableName)
      .then(function(exists) {
        if (exists === false) {
          return schema(knex)
            .createTable(tableName, _ref2)
            .then(_ref3)
        } else {
          log('table already exists:', tableName)
          return exists
        }
      })
  }

  return _regeneratorRuntime.wrap(
    function _callee$(_context) {
      while (1) {
        switch ((_context.prev = _context.next)) {
          case 0:
            _context.next = 2
            return Promise.all(columns.map(_ref)).then(_ref4)

          case 2:
            if (!(tableColumns !== void 0)) {
              _context.next = 5
              break
            }

            _context.next = 5
            return Promise.all(tableColumns.map(_ref5))

          case 5:
            return _context.abrupt('return', tableColumns || emptyArr)

          case 6:
          case 'end':
            return _context.stop()
        }
      }
    },
    _callee3,
    this
  )
}

function _createTable() {
  _createTable = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(_callee3)
  )
  return _createTable.apply(this, arguments)
}

export function dropTable(_x4, _x5, _x6) {
  return _dropTable.apply(this, arguments)
}

function _callee4(knex, tableName, columns) {
  function _ref6(c) {
    return c.setKnex(knex).down(tableName)
  }

  function _ref7(r) {
    log.success('dropped table:', tableName)
    return r
  }

  return _regeneratorRuntime.wrap(
    function _callee2$(_context2) {
      while (1) {
        switch ((_context2.prev = _context2.next)) {
          case 0:
            if (columns === void 0) {
              columns = emptyArr
            }

            _context2.next = 3
            return Promise.all(columns.map(_ref6))

          case 3:
            return _context2.abrupt(
              'return',
              knex.schema.dropTableIfExists(tableName).then(_ref7)
            )

          case 4:
          case 'end':
            return _context2.stop()
        }
      }
    },
    _callee4,
    this
  )
}

function _dropTable() {
  _dropTable = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(_callee4)
  )
  return _dropTable.apply(this, arguments)
}
