import _objectSpread from '@babel/runtime/helpers/objectSpread'
import _createClass from '@babel/runtime/helpers/createClass'
import _inheritsLoose from '@babel/runtime/helpers/inheritsLoose'
import emptyObj from 'empty/object'
import {client, log} from '../utils'
import getSchemaName from './getSchemaName'
import Query, {
  toUpper,
  safe,
  identifier,
  identifierBindings,
  conditionalBindings,
} from './Query'
var cache = {}

function _ref(a, i) {
  return (
    (a.IN ? 'IN' : a.OUT ? 'OUT' : '') +
    ':name' +
    i +
    ': ' +
    (':type' + i + ':' + (a.default ? ' DEFAULT :default' + i + ':' : ''))
  )
}

function createArgParams(args) {
  return '(' + args.map(_ref).join(',') + ')'
}

function createArgObj(args) {
  var argObj = {}
  args.forEach(function(a, i) {
    argObj['name' + i] = a.name
    argObj['type' + i] = a.type

    if (a.default) {
      argObj['default' + i] = a.default
    }
  })
  return argObj
} // NOTE: this only checks against function names in determining dupes,
// does not check argument types

function _ref2(exists) {
  if (exists.rows && exists.rows.length) {
    exists = exists.rows[0].exists
    return exists
  }

  return false
}

export function doesFunctionExist(knex, name, opt) {
  if (opt === void 0) {
    opt = emptyObj
  }

  var _opt = opt,
    _opt$schemaName = _opt.schemaName,
    schemaName =
      _opt$schemaName === void 0 ? getSchemaName(knex) : _opt$schemaName
  return knex
    .raw(
      '\n      SELECT EXISTS(\n        SELECT\n          p.proname\n        FROM\n          pg_catalog.pg_proc p\n        LEFT JOIN\n          pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n        WHERE\n          pg_catalog.pg_function_is_visible(p.oid)\n          AND p.proname = ?\n          AND n.nspname = ?\n      );\n    ',
      [name, schemaName]
    )
    .then(_ref2)
}

function _args(k, v) {
  if (!v || !v.length) {
    return '()'
  }

  return [createArgParams(v), createArgObj(v)]
}

function _body(k, v, bindings) {
  if (v) {
    return ['$$\n' + safe(v) + '\n$$', bindings || {}]
  }

  return v
}

function _then() {
  var _this2 = this,
    _this$_result

  function _ref3(r) {
    log.success('created function:', _this2.sqlName)
    return r
  }

  if (this._resolved === false) {
    if (this._args === null) {
      this.args()
    }

    this._resolved = true
    var funcName = this._nameBindings.nameBinding
    this._result = doesFunctionExist(this.knex, funcName).then(function(
      exists
    ) {
      if (exists === true) {
        log.warn('function already exists:', funcName)
        return exists
      }

      return _this2.knex.raw(_this2.sql, _this2.bindings).then(_ref3)
    })
  }

  return (_this$_result = this._result).then.apply(_this$_result, arguments)
}

function _get() {
  return (
    '\n      ' +
    this._nameBindings.nameBinding +
    this.knex
      .raw(this._args, this._argsBindings)
      .toSQL()
      .sql.replace(/\s*DEFAULT[^,)]+?([,)])/g, '$1') +
    '\n    '
  ).trim()
}

export var Func =
  /*#__PURE__*/
  (function(_Query) {
    _inheritsLoose(Func, _Query)

    function Func(knex, name, proc) {
      var _this

      _this =
        _Query.call(this, knex, {
          create: 'CREATE',
          orReplace: toUpper,
          func: 'FUNCTION',
          name: identifier,
          args: _args,
          returns: identifierBindings,
          returnsTrigger: toUpper,
          returnsTable: conditionalBindings,
          as: 'AS',
          body: _body,
          language: 'LANGUAGE PLPGSQL',
          with: conditionalBindings,
        }) || this

      _this.name(name)

      _this.body(proc)

      _this._resolved = false
      _this._result = null
      return _this
    }

    var _proto = Func.prototype
    _proto.then = _then

    _createClass(Func, [
      {
        key: 'sqlName',
        get: _get,
      },
    ])

    return Func
  })(Query)
export default function func(knex, name, body) {
  return new Func(knex, name, body)
}

function _ref4(a) {
  return _objectSpread({}, a, {
    default: void 0,
  })
}

function _args2(k, v) {
  if (!v || !v.length) {
    return '()'
  }

  v = v.map(_ref4)
  return [createArgParams(v), createArgObj(v)]
}

function _get2() {
  return (
    '\n      ' +
    this._nameBindings.nameBinding +
    this.knex.raw(this._args, this._argsBindings).toSQL().sql +
    '\n    '
  ).trim()
}

export var DropFunc =
  /*#__PURE__*/
  (function(_Query2) {
    _inheritsLoose(DropFunc, _Query2)

    function DropFunc(knex, name) {
      var _this3

      _this3 =
        _Query2.call(this, knex, {
          create: 'DROP',
          trigger: 'FUNCTION',
          ifExists: toUpper,
          name: identifier,
          args: _args2,
          cascade: toUpper,
          restrict: toUpper,
        }) || this

      _this3.name(name)

      return _this3
    }

    var _proto2 = DropFunc.prototype

    _proto2.then = function then() {
      var _Query2$prototype$the,
        _this4 = this

      if (this._args === null) {
        this.args()
      }

      return (_Query2$prototype$the = _Query2.prototype.then.call(
        this,
        function(r) {
          log.success('dropped function:', _this4.sqlName)
          return r
        }
      )).then.apply(_Query2$prototype$the, arguments)
    }

    _createClass(DropFunc, [
      {
        key: 'sqlName',
        get: _get2,
      },
    ])

    return DropFunc
  })(Query)
export function dropFunc(knex, name) {
  return new DropFunc(knex, name)
}
