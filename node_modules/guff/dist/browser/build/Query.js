import _objectSpread from '@babel/runtime/helpers/objectSpread'
import _createClass from '@babel/runtime/helpers/createClass'
import {client} from '../utils'
var upperRepl = /([A-Z]+)/g
export function toUpper(k, v) {
  if (v === false) {
    return null
  }

  return k.replace(upperRepl, ' $1').toUpperCase()
}
export function safe(v) {
  return v
}
export function identifier(k, v) {
  if (v !== void 0 && v !== null) {
    var _ref

    var bindingKey = k + 'Binding'
    return [':' + bindingKey + ':', ((_ref = {}), (_ref[bindingKey] = v), _ref)]
  }
}
export function identifierBindings(k, v) {
  if (v !== void 0 && v !== null) {
    var _ref2

    var bindingKey = k + 'Binding'
    return [
      toUpper(k) + ' :' + bindingKey + ':',
      ((_ref2 = {}), (_ref2[bindingKey] = v), _ref2),
    ]
  }
}
export function conditionalBindings(k, v) {
  if (v !== void 0 && v !== null) {
    var _ref3

    var bindingKey = k + 'Binding'
    return [
      toUpper(k) + ' :' + bindingKey,
      ((_ref3 = {}), (_ref3[bindingKey] = v), _ref3),
    ]
  }
}

function _Query(knex, insertionPoints) {
  this.knex = client(knex)

  this._setInsertionPoints(insertionPoints)

  this._result = null
  this._resolved = false
}

function _setInsertionPoints(insertionPoints) {
  var _this = this

  this.insertionPoints = insertionPoints
  Object.keys(insertionPoints).forEach(function(k) {
    var v = insertionPoints[k]
    var store = '_' + k

    if (typeof v === 'string') {
      _this[store] = v
      return
    } else {
      _this[store] = null
    }

    _this[store + 'Bindings'] = {}

    var attachBindings = function attachBindings(v) {
      if (Array.isArray(v)) {
        _this[store + 'Bindings'] = _objectSpread({}, v[1])
        return v[0]
      }

      return v
    }

    function _ref4() {
      for (
        var _len = arguments.length, args = new Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        args[_key] = arguments[_key]
      }

      _this[store] = attachBindings(v.apply(void 0, [k].concat(args)))
      return _this
    }

    function _loop3(o) {
      var fn = v.aggregate[o]

      _this[o] = function() {
        for (
          var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
          _key2 < _len2;
          _key2++
        ) {
          args[_key2] = arguments[_key2]
        }

        var ov = attachBindings(fn.apply(void 0, [o].concat(args)))

        if (ov === null) {
          _this[store].splice(_this[store].indexOf(ov), 1)
        } else {
          if (_this[store].indexOf(ov) === -1) {
            _this[store].push(ov)
          }
        }

        return _this
      }
    }

    function _loop4(o) {
      var fn = v.options[o]

      _this[o] = function() {
        for (
          var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;
          _key3 < _len3;
          _key3++
        ) {
          args[_key3] = arguments[_key3]
        }

        _this[store] = attachBindings(fn.apply(void 0, [o].concat(args)))
        return _this
      }
    }

    if (typeof v === 'function') {
      _this[k] = _ref4
    } else if (typeof v === 'object') {
      if (v.aggregate) {
        _this[store] = []
        _this[store + 'Joiner'] = v.joiner
        var _loop = _loop3

        for (var o in v.aggregate) {
          _loop(o)
        }
      } else if (v.options) {
        var _loop2 = _loop4

        for (var o in v.options) {
          _loop2(o)
        }
      }
    }
  })
}

function _then() {
  var _this$_result

  if (this._resolved === false) {
    this._resolved = true
    this._result = this.knex.raw(this.sql, this.bindings)
  }

  return (_this$_result = this._result).then.apply(_this$_result, arguments)
}

function _get() {
  var _this2 = this

  var query = Object.keys(this.insertionPoints)
    .filter(function(k) {
      return _this2['_' + k] !== null
    })
    .map(function(k) {
      return Array.isArray(_this2['_' + k])
        ? _this2['_' + k].join(_this2['_' + k + 'Joiner'])
        : _this2['_' + k]
    })
  return query.join(' ')
}

function _get2() {
  var _this3 = this

  var bindings = {}
  Object.keys(this.insertionPoints)
    .filter(function(k) {
      return (
        _this3['_' + k + 'Bindings'] !== void 0 &&
        _this3['_' + k + 'Bindings'] !== null
      )
    })
    .forEach(function(k) {
      return Object.assign(bindings, _this3['_' + k + 'Bindings'])
    })
  return bindings
}

var Query =
  /*#__PURE__*/
  (function() {
    var _proto = _Query.prototype
    _proto._setInsertionPoints = _setInsertionPoints
    _proto.then = _then

    _createClass(_Query, [
      {
        key: 'sql',
        get: _get,
      },
      {
        key: 'bindings',
        get: _get2,
      },
    ])

    return _Query
  })()

export {Query as default}
