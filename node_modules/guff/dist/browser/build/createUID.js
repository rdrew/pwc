import _regeneratorRuntime from '@babel/runtime/regenerator'
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator'
import emptyObj from 'empty/object'
import invariant from 'invariant'
import {schema, log} from '../utils'
import getSchemaName from './getSchemaName'
import createTable, {dropTable} from './createTable'
import column from './column'
import trigger, {dropTrigger} from './trigger'
import sequence, {dropSequence} from './sequence'
import func, {dropFunc} from './func' // sets date to 1 day ago to avoid negative numbers do to clock shifts

var date = Date.now() - 86400 * 1000
var cache = {}
var body =
  "\n-- The shard ID, must be unique for each shard\nDECLARE\n    -- !! custom epoch, this will work for 41 years after the epoch\n    start_epoch bigint := :epoch:;\n    -- Declares big integer variables we will use to calculate the uuid\n    seq_id bigint;\n    now_millis bigint;\n    result bigint;\nBEGIN\n    -- Selects the next value of the sequence we created earlier\n    -- and performs a modulus operator on it so that it fits in to\n    -- 10 bits (this is where the 1024 comes from).\n    SELECT mod(nextval(':seqName:'), 1024) INTO seq_id;\nSELECT FLOOR(EXTRACT(EPOCH FROM clock_timestamp()) * 1000) INTO now_millis;\n    -- left shifts 41 bits (64 - 41)\n    result := (now_millis - start_epoch) << 23;\n    -- left shifts 13 bits (64 - 41 - 13)\n    result := result | (shard_id << 10);\n    -- fills remaining 10 bits (from the modulus operation above)\n    result := result | (seq_id);\n    RETURN result;\nEND;\n"
var uidArgs = [
  {
    name: 'shard_id',
    type: 'int4',
    default: 1,
  },
]
/**
========================================================================
Creates a 64-bit universally unique id. This is accomplished by
calculating a 41-bit representation of the milliseconds from a given
start epoch, using a 13-bit representation of the ID number of the
shard, and a 10-bit representation of a global ID sequence for a given
schema.
------------------------------------------------------------------------
The UID can be sorted by its insertion order, that is, rows submitted
sequentially will remain sequential in terms of their UID.
------------------------------------------------------------------------
64-bit UID is delegated like so:
* 41-bit time in milliseconds since epoch (gives 41 years of IDs)
* 13-bit logical shard ID
* 10-bit representation of an auto-incrementing sequence, modulus 1024.
    This means we can generate 1024 IDs, per shard, per millisecond.
========================================================================
A modulus operation works like this:
1. Say the 'nextval' is 5061 and the modulo is 1024
    |5061 % 1024|
2. Divide 'nextval' by the modulo (1024 in this case)
    |5061 / 1024 = 4.942|
3. Multiply the INTEGER value of step 2 by the modulo (1024)
    |INT 4.942 = 4|
    |4 * 1024 = 4096|
4. Subtract step 3 from 'nextval' to get the difference,
    this is the result of the operation
    |5061 - 4096 = 965|
|Result: 5061 % 1024 = 965|
The maximum number in 10 bits is 1024.  Therefore, by taking the modulo
of the sequence ids, we always get a number which is between 1 and
1024. If we wanted the number to fit in an 8 bit representation we
could set the modulo to 256.
========================================================================
At scale, simply find/replace out {schema} for each shard you have.
To use, set the |uid| field default value to |{schema}.cargo_uid()|
where X is the shard ID. The |uid| field must be of type BIGINT (int8)
in order to work properly as an integer field. It could still be placed
in a text field, etc.
Credit to:
http://rob.conery.io/2014/05/29/a-better-id-generator-for-postgresql/
*/

export default function createUID(_x, _x2) {
  return _createUID.apply(this, arguments)
}

function _callee5(knex, opt) {
  var _opt,
    _opt$name,
    name,
    _opt$epoch,
    epoch,
    _opt$seqCache,
    seqCache,
    _opt$seqName,
    seqName,
    schemaName,
    key

  return _regeneratorRuntime.wrap(
    function _callee$(_context) {
      while (1) {
        switch ((_context.prev = _context.next)) {
          case 0:
            if (opt === void 0) {
              opt = emptyObj
            }

            !(knex !== void 0)
              ? process.env.NODE_ENV !== 'production'
                ? invariant(
                    false,
                    'createUID function requires that you provide a knex instance ' +
                      'as the first argument'
                  )
                : invariant(false)
              : void 0
            ;(_opt = opt),
              (_opt$name = _opt.name),
              (name = _opt$name === void 0 ? 'guff_uid' : _opt$name),
              (_opt$epoch = _opt.epoch),
              (epoch = _opt$epoch === void 0 ? date : _opt$epoch),
              (_opt$seqCache = _opt.seqCache),
              (seqCache = _opt$seqCache === void 0 ? 1024 : _opt$seqCache),
              (_opt$seqName = _opt.seqName),
              (seqName =
                _opt$seqName === void 0 ? 'guff_uid_seq' : _opt$seqName)
            schemaName = getSchemaName(knex)
            key = JSON.stringify({
              name: name,
              epoch: epoch,
              seqCache: seqCache,
              seqName: seqName,
              schemaName: schemaName,
            })

            if (!(cache[key] === void 0)) {
              _context.next = 9
              break
            }

            _context.next = 8
            return createUIDSeq(knex, name, seqCache)

          case 8:
            cache[key] = func(knex, name)
              .body(body, {
                epoch: epoch,
                seqName: schemaName + '.' + seqName,
              })
              .args(uidArgs)
              .returns('int8')

          case 9:
            return _context.abrupt('return', cache[key])

          case 10:
          case 'end':
            return _context.stop()
        }
      }
    },
    _callee5,
    this
  )
}

function _createUID() {
  _createUID = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(_callee5)
  )
  return _createUID.apply(this, arguments)
}

export function createUIDSeq(knex, name, cacheSize) {
  if (cacheSize === void 0) {
    cacheSize = 1000
  }

  return sequence(knex, name + '_seq')
    .ifNotExists()
    .noMinvalue()
    .noMaxvalue()
    .cache(cacheSize)
}
export function dropUID(_x3, _x4) {
  return _dropUID.apply(this, arguments)
}

function _callee6(knex, name) {
  var dropped
  return _regeneratorRuntime.wrap(
    function _callee2$(_context2) {
      while (1) {
        switch ((_context2.prev = _context2.next)) {
          case 0:
            if (name === void 0) {
              name = 'guff_uid'
            }

            dropped = dropFunc(knex, name)
              .args(uidArgs)
              .ifExists()
              .cascade()
            _context2.next = 4
            return dropSequence(knex, name)
              .ifExists()
              .cascade()

          case 4:
            return _context2.abrupt('return', dropped)

          case 5:
          case 'end':
            return _context2.stop()
        }
      }
    },
    _callee6,
    this
  )
}

function _dropUID() {
  _dropUID = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(_callee6)
  )
  return _dropUID.apply(this, arguments)
}

export function createKnownUIDTable(knex) {
  return createTable(knex, 'guff_known_uid', [
    column('uid', 'bigInteger')
      .defaultTo(null)
      .primary(),
    column('ref', 'text').notNullable(),
  ])
}
export function dropKnownUIDTable(knex) {
  return dropTable(knex, 'guff_known_uid')
}

var getInsertKnownUIDFunc = function getInsertKnownUIDFunc(columnName) {
  return (
    '\nBEGIN\n  INSERT INTO guff_known_uid (uid, ref) VALUES (NEW.' +
    columnName +
    ', TG_TABLE_NAME);\n  RETURN NULL;\nEND;\n'
  )
}

var getDeleteKnownUIDFunc = function getDeleteKnownUIDFunc(columnName) {
  return (
    '\nBEGIN\n  DELETE FROM guff_known_uid WHERE uid = OLD.' +
    columnName +
    ';\n  RETURN NULL;\nEND;\n'
  )
}

var getKnownInsertName = function getKnownInsertName(table, columnName) {
  return 'guff_insert_' + table + '_' + columnName
}

var getKnownDeleteName = function getKnownDeleteName(table, columnName) {
  return 'guff_delete_' + table + '_' + columnName
}

export function createKnownUIDTrigger(_x5, _x6, _x7) {
  return _createKnownUIDTrigger.apply(this, arguments)
}

function _callee7(knex, table, columnName) {
  var insertName, insertFn, deleteName, deleteFn
  return _regeneratorRuntime.wrap(
    function _callee3$(_context3) {
      while (1) {
        switch ((_context3.prev = _context3.next)) {
          case 0:
            insertName = getKnownInsertName(table, columnName)
            insertFn = func(
              knex,
              insertName,
              getInsertKnownUIDFunc(columnName)
            ).returnsTrigger()
            deleteName = getKnownDeleteName(table, columnName)
            deleteFn = func(
              knex,
              deleteName,
              getDeleteKnownUIDFunc(columnName)
            ).returnsTrigger()
            _context3.next = 6
            return Promise.all([insertFn, deleteFn])

          case 6:
            _context3.next = 8
            return Promise.all([
              trigger(insertFn)
                .on(table)
                .eachRow()
                .after()
                .insert(),
              trigger(deleteFn)
                .on(table)
                .eachRow()
                .after()
                .delete(),
            ])

          case 8:
            return _context3.abrupt('return', _context3.sent)

          case 9:
          case 'end':
            return _context3.stop()
        }
      }
    },
    _callee7,
    this
  )
}

function _createKnownUIDTrigger() {
  _createKnownUIDTrigger = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(_callee7)
  )
  return _createKnownUIDTrigger.apply(this, arguments)
}

export function dropKnownUIDTrigger(_x8, _x9, _x10) {
  return _dropKnownUIDTrigger.apply(this, arguments)
}

function _callee8(knex, table, columnName) {
  var insertName, droppedInsert, deleteName, droppedDelete
  return _regeneratorRuntime.wrap(
    function _callee4$(_context4) {
      while (1) {
        switch ((_context4.prev = _context4.next)) {
          case 0:
            insertName = getKnownInsertName(table, columnName)
            droppedInsert = dropFunc(knex, insertName)
              .ifExists()
              .cascade()
            deleteName = getKnownDeleteName(table, columnName)
            droppedDelete = dropFunc(knex, deleteName)
              .ifExists()
              .cascade()
            _context4.next = 6
            return Promise.all([
              dropTrigger(knex, insertName + '_trigger')
                .ifExists()
                .on(table),
              dropTrigger(knex, deleteName + '_trigger')
                .ifExists()
                .on(table),
            ])

          case 6:
            _context4.next = 8
            return Promise.all([droppedInsert, droppedDelete])

          case 8:
            return _context4.abrupt('return', _context4.sent)

          case 9:
          case 'end':
            return _context4.stop()
        }
      }
    },
    _callee8,
    this
  )
}

function _dropKnownUIDTrigger() {
  _dropKnownUIDTrigger = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(_callee8)
  )
  return _dropKnownUIDTrigger.apply(this, arguments)
}
