import emptyObj from 'empty/object'
import {log} from '../utils'
import Query, {
  toUpper,
  identifier,
  identifierBindings,
  conditionalBindings,
} from './Query'

function _ref() {
  return 'FOR EACH ROW'
}

function _ref2() {
  return 'FOR EACH STATEMENT'
}

export class Trigger extends Query {
  constructor(knex, name, proc) {
    super(knex, {
      create: 'CREATE',
      constraint: toUpper,
      trigger: 'TRIGGER',
      name: identifier,
      whenEvent: {
        options: {
          before: toUpper,
          after: toUpper,
          insteadOf: toUpper,
        },
      },
      event: {
        joiner: ' OR ',
        aggregate: {
          insert: toUpper,
          update: toUpper,
          delete: toUpper,
          truncate: toUpper,
        },
      },
      on: identifierBindings,
      from: identifierBindings,
      timing: {
        options: {
          notDeferrable: toUpper,
          deferrable: toUpper,
          initiallyImmediate: toUpper,
          initiallyDeferred: toUpper,
        },
      },
      forEach: {
        options: {
          eachRow: _ref,
          eachStmt: _ref2,
        },
      },
      when: conditionalBindings,
      executeProcedure: identifierBindings,
    })
    this.name(name)
    this.executeProcedure(proc)
  }

  get sqlName() {
    return this._nameBindings.nameBinding
  }

  then(...args) {
    return super
      .then(r => {
        log.success('created trigger:', this.sqlName)
        return r
      })
      .then(...args)
  }
}

function makeName(name) {
  return `${name.split('(')[0].trim()}_trigger`
}

export default function trigger(knex, name, proc) {
  if (name === void 0) {
    proc = knex.sqlName
    name = makeName(proc)
    knex = knex.knex
    proc = knex.raw(proc)
  }

  if (proc === void 0) {
    proc = name
    proc = typeof proc === 'string' ? proc : proc.sqlName
    proc = knex.raw(proc)
    name = makeName(name)
  }

  return new Trigger(knex, name, proc)
}
export class DropTrigger extends Query {
  constructor(knex, name) {
    super(knex, {
      create: 'DROP',
      trigger: 'TRIGGER',
      ifExists: toUpper,
      name: identifier,
      on: identifierBindings,
      cascade: toUpper,
      restrict: toUpper,
    })
    this.name(name)
  }

  get sqlName() {
    return this._nameBindings.nameBinding
  }

  then(...args) {
    return super
      .then(r => {
        log.success('dropped trigger:', this.sqlName)
        return r
      })
      .then(...args)
  }
}
export function dropTrigger(knex, name) {
  return new DropTrigger(knex, name)
}
