import _objectSpread from '@babel/runtime/helpers/objectSpread'
import emptyObj from 'empty/object'
import {client, log} from '../utils'
import getSchemaName from './getSchemaName'
import Query, {
  toUpper,
  safe,
  identifier,
  identifierBindings,
  conditionalBindings,
} from './Query'
const cache = {}

function _ref(a, i) {
  return (
    `${a.IN ? 'IN' : a.OUT ? 'OUT' : ''}:name${i}: ` +
    `:type${i}:${a.default ? ` DEFAULT :default${i}:` : ''}`
  )
}

function createArgParams(args) {
  return `(${args.map(_ref).join(',')})`
}

function createArgObj(args) {
  const argObj = {}
  args.forEach((a, i) => {
    argObj[`name${i}`] = a.name
    argObj[`type${i}`] = a.type

    if (a.default) {
      argObj[`default${i}`] = a.default
    }
  })
  return argObj
} // NOTE: this only checks against function names in determining dupes,
// does not check argument types

function _ref2(exists) {
  if (exists.rows && exists.rows.length) {
    exists = exists.rows[0].exists
    return exists
  }

  return false
}

export function doesFunctionExist(knex, name, opt = emptyObj) {
  const {schemaName = getSchemaName(knex)} = opt
  return knex
    .raw(
      `
      SELECT EXISTS(
        SELECT
          p.proname
        FROM
          pg_catalog.pg_proc p
        LEFT JOIN
          pg_catalog.pg_namespace n ON n.oid = p.pronamespace
        WHERE
          pg_catalog.pg_function_is_visible(p.oid)
          AND p.proname = ?
          AND n.nspname = ?
      );
    `,
      [name, schemaName]
    )
    .then(_ref2)
}

function _ref3(k, v) {
  if (!v || !v.length) {
    return '()'
  }

  return [createArgParams(v), createArgObj(v)]
}

function _ref4(k, v, bindings) {
  if (v) {
    return [`$$\n${safe(v)}\n$$`, bindings || {}]
  }

  return v
}

export class Func extends Query {
  constructor(knex, name, proc) {
    super(knex, {
      create: 'CREATE',
      orReplace: toUpper,
      func: 'FUNCTION',
      name: identifier,
      args: _ref3,
      returns: identifierBindings,
      returnsTrigger: toUpper,
      returnsTable: conditionalBindings,
      as: 'AS',
      body: _ref4,
      language: 'LANGUAGE PLPGSQL',
      with: conditionalBindings,
    })
    this.name(name)
    this.body(proc)
    this._resolved = false
    this._result = null
  }

  get sqlName() {
    return `
      ${this._nameBindings.nameBinding}${this.knex
      .raw(this._args, this._argsBindings)
      .toSQL()
      .sql.replace(/\s*DEFAULT[^,)]+?([,)])/g, '$1')}
    `.trim()
  }

  then(...args) {
    if (this._resolved === false) {
      if (this._args === null) {
        this.args()
      }

      this._resolved = true
      const funcName = this._nameBindings.nameBinding
      this._result = doesFunctionExist(this.knex, funcName).then(exists => {
        if (exists === true) {
          log.warn(`function already exists:`, funcName)
          return exists
        }

        return this.knex.raw(this.sql, this.bindings).then(r => {
          log.success('created function:', this.sqlName)
          return r
        })
      })
    }

    return this._result.then(...args)
  }
}
export default function func(knex, name, body) {
  return new Func(knex, name, body)
}

function _ref5(a) {
  return _objectSpread({}, a, {
    default: void 0,
  })
}

function _ref6(k, v) {
  if (!v || !v.length) {
    return '()'
  }

  v = v.map(_ref5)
  return [createArgParams(v), createArgObj(v)]
}

export class DropFunc extends Query {
  constructor(knex, name) {
    super(knex, {
      create: 'DROP',
      trigger: 'FUNCTION',
      ifExists: toUpper,
      name: identifier,
      args: _ref6,
      cascade: toUpper,
      restrict: toUpper,
    })
    this.name(name)
  }

  get sqlName() {
    return `
      ${this._nameBindings.nameBinding}${
      this.knex.raw(this._args, this._argsBindings).toSQL().sql
    }
    `.trim()
  }

  then(...args) {
    if (this._args === null) {
      this.args()
    }

    return super
      .then(r => {
        log.success('dropped function:', this.sqlName)
        return r
      })
      .then(...args)
  }
}
export function dropFunc(knex, name) {
  return new DropFunc(knex, name)
}
